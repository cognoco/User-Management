# Development Methodology

This document outlines the standardized processes and workflows for developing the Pluggable User Management Platform (PUMP). Adhering to these guidelines is mandatory to ensure code quality, consistency, and effective collaboration, especially when working with AI Developer Agents.

The static coding rules (naming conventions, linting) are defined in the main [Architecture](./03-Architecture.md#19-coding-standards) document.

## 1. Git Workflow: GitHub Flow

We use a simple and effective **GitHub Flow** model.

1.  **`main` is the Source of Truth:** The `main` branch is always considered stable and deployable. Direct commits to `main` are strictly forbidden.
2.  **Create a Feature Branch:** All new work, including features, bug fixes, or chores, **MUST** be done on a descriptive feature branch created from `main`.
    -   **Branch Naming:** Branches should be named using the `type/short-description` format (e.g., `feat/user-auth-endpoint`, `fix/incorrect-permission-check`).
3.  **Commit Convention:** All commits **MUST** adhere to the **Conventional Commits** specification. This is critical for automated versioning and changelog generation.
    -   **Format:** `<type>(<scope>): <subject>` (e.g., `feat(auth): add password reset flow`).
    -   **Common Types:** `feat`, `fix`, `chore`, `docs`, `style`, `refactor`, `test`.
4.  **Pull Requests (PRs):** When work is complete, open a Pull Request to merge the feature branch into `main`.
    -   **PR Template:** The PR description should be clear, explaining the "what" and "why" of the change. It must link to the relevant task or issue.
    -   **CI Checks:** All automated checks (linting, testing, builds) **MUST** pass before a PR can be merged.
    -   **Review:** All PRs require at least one approving review from a team member.
5.  **Merge:** Once approved and all checks pass, the branch can be merged into `main` using a **squash merge**. This keeps the history of `main` clean and linear.

## 2. Dependency Management

-   **Approval:** Adding new third-party dependencies requires discussion and approval to minimize the project's footprint and security surface.
-   **Updates:** Dependencies should be kept up-to-date. Regularly review for security vulnerabilities using automated tools.

## 3. Documentation Policy

-   **Code Comments:**
    -   Write comments for the "why," not the "what." Explain complex logic, business rules, or the reasoning behind a particular implementation choice.
    -   Use `// TODO:` for planned future work and `// FIXME:` for known issues that need to be addressed.
-   **READMEs:** Every module or significant component should have a `README.md` file that explains its purpose, how to use it, and its key functions/components.
-   **Architecture Documents:** All new features or significant changes must be reflected in the relevant architecture documents (`Architecture.md`, `ImplementationGuide.md`).

## 4. Guidance for AI Developer Agents

This section provides critical instructions for AI agents to ensure they operate effectively within our development process.

-   **Context is Key:** Before writing any code, you **MUST** first understand the context. This involves:
    1.  Reading the relevant task or issue description.
    2.  Reviewing the linked sections of the `Architecture.md` and `ImplementationGuide.md`.
    3.  Listing the files you intend to modify and asking for confirmation before proceeding.
-   **Adherence to Standards:** You **MUST** strictly follow all defined coding standards, including file naming, commit conventions, and documentation policies. Your generated code will be rejected by CI if it does not comply.
-   **Incremental Changes:** Do not attempt to solve large, complex tasks in a single step.
    1.  Propose a clear, step-by-step plan.
    2.  Implement each step as a distinct, small change.
    3.  Verify each change before moving to the next step.
-   **Ask, Don't Assume:** If a requirement is unclear or there are multiple ways to implement a solution, you **MUST** ask for clarification. Present the options with their pros and cons.
-   **Ownership and Verification:** You are responsible for the code you generate. This includes:
    1.  Writing or updating tests that validate your changes.
    2.  Ensuring your code passes all linting and build checks.
    3.  Updating relevant documentation (`READMEs`, etc.).

## 5. Security Procedures

-   **Dependency Security:**
    -   **Process:** Project dependencies **MUST** be regularly scanned for known vulnerabilities using `pnpm audit`. This check will be integrated into the CI pipeline.
    -   **Remediation:** High and Critical severity vulnerabilities **MUST** be addressed promptly (updated, replaced, or have a documented mitigation) before code can be merged into the `main` branch.
    -   **Vetting New Dependencies:** Before adding any new third-party dependency, it must be vetted for necessity, security posture, and license compatibility.

## 6. Workflow Model

-   **[Placeholder]** This section will define whether we are using a Scrum, Kanban, or a hybrid model. It will detail the ceremonies (e.g., stand-ups, planning, retrospectives), roles, and artifacts.

## 7. Branching and Versioning Strategy

-   **[Placeholder]** This section will expand upon the Git-flow and Conventional Commits strategy mentioned in the Architecture document. It will provide detailed examples and guidelines for branch naming, PR descriptions, and release versioning (e.g., Semantic Versioning).

## 8. Code Review Process

-   **[Placeholder]** This section will define the process for code reviews, including:
    -   Minimum number of reviewers.
    -   Guidelines for providing constructive feedback.
    -   Checklists for reviewers to ensure consistency (e.g., checking for tests, documentation, adherence to standards).
    -   The role of automated checks (CI) in the review process.

## 9. Definition of Done (DoD)

-   **[Placeholder]** A clear and unambiguous checklist that a feature or task must satisfy to be considered "done." This will likely include:
    -   Code implemented and merged to `main`.
    -   All acceptance criteria from the task description are met.
    -   Unit and integration tests are written and passing.
    -   E2E tests are updated or created for critical paths.
    -   Documentation (if required) is updated.
    -   Code has been successfully deployed to the preview/staging environment.

## 10. Task Management

-   **[Placeholder]** Guidelines for using the project's task management tool (e.g., Jira, Linear, GitHub Issues). This will cover ticket creation, status updates, and linking commits and PRs to tasks.

## 11. Environment Promotion & Release Process

This section outlines the process for promoting code through to production.

-   **Promotion Flow:** The release process follows the **GitHub Flow** model.
    1.  A feature is developed on a feature branch.
    2.  A Pull Request is opened, which triggers the CI pipeline and deployment of a preview environment.
    3.  After review and all checks passing, the PR is merged to `main`.
    4.  The merge to `main` triggers a workflow that builds and pushes the production-candidate Docker image to the container registry.
    5.  This new image is then deployed to the production environment.
-   **Database Migration Process (MVP):**
    -   To ensure maximum safety, database migrations are a **manual process** for the MVP.
    -   Migrations generated locally **MUST** first be applied to the Staging environment and thoroughly tested.
    -   Only after successful staging verification can the migrations be applied to the Production database. 