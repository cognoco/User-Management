# PUMP: Implementation Guide

**Version:** 0.1
**Status:** DRAFT

## 1. Introduction

This document provides tactical, hands-on guidance for developers working with the Pluggable User Management Platform (PUMP). It is the primary resource for understanding *how* to implement features, add new integrations, and customize the platform. It complements the strategic `Architecture.md` document.

This guide is organized into two primary parts:
-   **Host Integration:** For developers of external applications who are consuming the PUMP.
-   **Internal Development:** For developers who are building and extending the PUMP itself.

## 2. Host Application Integration Guide

This section details the practical steps required for a Host Application to integrate with the PUMP.

### 2.1. Initial Setup: Subdomain & DNS

Before integration, you must configure a dedicated subdomain for the PUMP to operate on.

1.  **Choose a Subdomain:** Select a subdomain for the PUMP instance (e.g., `auth.yourapp.com`).
2.  **Configure DNS:** In your DNS provider, create a `CNAME` record pointing your chosen subdomain to the deployment target of your PUMP instance (e.g., `pump-instance-123.on-render.com`).

### 2.2. Integrating the Client SDK

The primary way to interact with the PUMP from a React-based host application is via the `@pump/client-sdk`.

1.  **Installation:**
    ```bash
    npm install @pump/client-sdk
    ```

2.  **Provider Setup:** Wrap your host application's root component with the `PUMPAuthProvider`. This makes the authentication context available throughout your app.

    ```typescript
    // In your main App component (e.g., _app.tsx or layout.tsx)
    import { PUMPAuthProvider } from '@pump/client-sdk';

    const pumpAuthOptions = {
      apiUrl: 'https://auth.yourapp.com/api/trpc', // URL to your PUMP backend
      loginUrl: '/login', // Path on your PUMP instance
    };

    export default function RootLayout({ children }) {
      return (
        <PUMPAuthProvider options={pumpAuthOptions}>
          {children}
        </PUMPAuthProvider>
      );
    }
    ```

### 2.3. Handling Authentication Flows

The SDK makes it simple to handle login, logout, and registration.

1.  **Using the `useAuth` Hook:** Access the authentication state and functions from any component.

    ```typescript
    import { useAuth } from '@pump/client-sdk';

    function MyComponent() {
      const { isAuthenticated, user, loginWithRedirect, logout } = useAuth();

      if (!isAuthenticated) {
        return <button onClick={() => loginWithRedirect()}>Login</button>;
      }

      return (
        <div>
          <p>Welcome, {user.email}!</p>
          <button onClick={() => logout()}>Logout</button>
        </div>
      );
    }
    ```

2.  **Login Flow:** Calling `loginWithRedirect()` will automatically redirect the user to the PUMP's login page. After successful authentication, the user will be redirected back to your application.

3.  **Protecting Routes:** The SDK will provide a `withAuth` Higher-Order Component (HOC) or a similar mechanism to easily protect pages that require authentication.

### 2.4. Theming the PUMP UI

To ensure brand consistency, you can provide a theme configuration object to your PUMP instance.

1.  **Define Theme Object:** Create a JSON object that defines your brand's colors, fonts, and logo URL.

    ```json
    {
      "colors": {
        "primary": "#6D28D9",
        "primaryForeground": "#FFFFFF",
        "button": {
          "primary": "#6D28D9",
          "hover": "#5B21B6"
        }
      },
      "logo": {
        "light": "https://yourapp.com/logo-dark.png",
        "dark": "https://yourapp.com/logo-light.png"
      },
      "font": {
        "sans": "Inter, sans-serif"
      }
    }
    ```

2.  **Apply Theme:** This theme object is passed as a configuration option during the deployment of your PUMP instance (e.g., via an environment variable `PUMP_THEME_CONFIG`). Refer to the PUMP deployment guide for specifics.

### 2.5. Making Authenticated API Calls

The SDK automatically handles attaching the JWT to API calls made to the PUMP backend. If you need to make authenticated calls from your own backend, you must extract the JWT and pass it along.

1.  **Get Session Token:** The SDK will expose a function to retrieve the current session token.

    ```typescript
    const { getToken } = useAuth();

    async function handleApiCall() {
      const token = await getToken();
      
      const response = await fetch('https://your-backend.com/api/protected-route', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      // ...
    }
    ```
2.  **Backend Verification:** Your own backend must then validate this JWT against the PUMP's public key. The endpoint to retrieve the public key will be available on your PUMP instance.

---

## 3. Core Implementation Patterns

This section details the primary code-level patterns used throughout the platform for internal development.

### 3.1. Service Layer Implementation

Services contain the core business logic. They depend only on adapter interfaces and core domain types.

**Example: Default User Service**
```typescript
import { User, NewUser } from '@packages/shared-types';
import { IUserRepository } from '../repositories/interfaces/user-repository.interface';
import { IUserService } from './interfaces/user-service.interface';

export class DefaultUserService implements IUserService {
  constructor(private userRepository: IUserRepository) {}

  async getUser(id: string): Promise<User | null> {
    // Business logic can be added here (e.g., checking permissions)
    return this.userRepository.findById(id);
  }

  async createUser(data: NewUser): Promise<User> {
    // Business logic (e.g., validating input, setting defaults)
    return this.userRepository.create(data);
  }
  // ... other user-related methods
}
```

### 3.2. Adapter Layer Implementation

Adapters are responsible for all external integrations. They translate the platform's internal requests into the specific format required by a third-party service or database.

**Example: Prisma User Adapter**
```typescript
import { PrismaClient } from '@prisma/client';
import { User, NewUser } from '@packages/shared-types';
import { IUserRepository } from '../repositories/interfaces/user-repository.interface';

export class PrismaUserAdapter implements IUserRepository {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async findById(id: string): Promise<User | null> {
    const user = await this.prisma.user.findUnique({ where: { id } });
    // Data mapping from Prisma model to our domain 'User' type would happen here
    return user;
  }

  async create(data: NewUser): Promise<User> {
    const newUser = await this.prisma.user.create({ data });
    // Data mapping
    return newUser;
  }
  // ...
}
```

### 3.3. Hook Layer Implementation

React hooks provide a clean, reusable way to connect UI components to the backend services. They manage state, handle asynchronous actions, and expose data and callbacks to the UI.

**Example: `useUser` Hook**
```typescript
import { useState, useEffect, useCallback } from 'react';
import { getContainer } from '../lib/container'; // Service container/locator
import { IUserService } from '../services/interfaces/user-service.interface';
import { User } from '@packages/shared-types';

export function useUser(userId: string) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const userService = getContainer().resolve<IUserService>('IUserService');

  const loadUser = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const userData = await userService.getUser(userId);
      setUser(userData);
    } catch (err) {
      setError(err as Error);
    } finally {
      setIsLoading(false);
    }
  }, [userId, userService]);

  useEffect(() => {
    if (userId) {
      loadUser();
    }
  }, [loadUser, userId]);

  return { user, isLoading, error, reload: loadUser };
}
```

## 4. Extending the Platform

### 4.1. How to Add a New Service Provider

1.  **Identify the Interface:** Locate the service interface you need to implement (e.g., `IAuthService`, `IPaymentService`).
2.  **Create the Adapter:** Create a new class in the `adapters` directory (e.g., `adapters/auth/auth0.ts`) that implements the interface.
3.  **Implement All Methods:** Write the code to translate each method call into API calls for the new provider.
4.  **Update the Factory:** In the corresponding factory function (e.g., `getAuthService()`), add a case for your new provider.
5.  **Update Configuration:** Change the relevant environment variable (e.g., `AUTH_PROVIDER="auth0"`) to activate your new adapter.

### 4.2. How to Customize the UI

The UI is built with headless components to maximize customizability.

-   **Styled Components:** You can modify the CSS classes applied to the styled components in `components/ui/` to match the host application's design system.
-   **Headless Components & Render Props:** For more complex customizations, many components will expose a headless version or use render props, allowing the host application to supply its own rendering logic while preserving the core behavior.

## 5. Security Implementation Details

### 5.1. JWT Session Handling

-   The platform uses JWT-based sessions managed by the configured `AuthService`.
-   Upon successful login, a token is generated and should be stored in an **HTTP-only cookie** to mitigate XSS risks. This is the responsibility of the API route handler that calls the service.
-   The tRPC middleware must inspect this cookie on every protected API call, validate the token, and attach the user session to the request context.

### 5.2. RBAC Enforcement

Role-based access control is enforced in the service layer before any business logic is executed. A permission-checking utility should be used.

**Example within a Service Method:**
```typescript
import { checkPermission } from '../lib/rbac';

class TeamService implements ITeamService {
  async removeMember(actingUserId: string, teamId: string, memberToRemoveId: string): Promise<void> {
    // Enforce permissions before executing logic
    await checkPermission(actingUserId, 'delete:team_member', { teamId });

    // If permission check passes, proceed with business logic...
    // ...
  }
}
```

## 6. API Implementation Details

This section provides concrete examples and values for implementing the PUMP API.

### 6.1. Request & Response Payloads

The following are the canonical TypeScript interfaces for key API procedures. These should be defined as Zod schemas in the `packages/shared-types` directory.

**Corporate & Private User Registration:**
```typescript
export interface RegisterRequest {
  userType: 'private' | 'corporate';
  email: string;
  password: string;
  firstName?: string;
  lastName?: string;
  companyName?: string;
  companyWebsite?: string;
  department?: string;
  industry?: string;
  companySize?:
    | '1-10'
    | '11-50'
    | '51-200'
    | '201-500'
    | '501-1000'
    | '1000+'
    | 'Other/Not Specified';
  position?: string;
  acceptTerms: boolean;
}
```

**Login Response:**
```typescript
export interface LoginResponse {
  user: User; // Your internal User type
  token: string;
  requiresMfa: boolean;
  expiresAt?: string;
}
```

### 6.2. Structured Error Handling

All API procedures that can fail should return a structured error object.

**Error Response Interface:**
```typescript
export interface ErrorResponse {
  error: {
    code: string; // A machine-readable error code
    message: string; // A human-readable message
    details?: any; // Optional structured details
    category?: 'auth' | 'validation' | 'payment'; // Optional category
  }
}
```

**Common Error Codes:**
| Code | Meaning | Retry Guidance |
|---|---|---|
| `auth/unauthorized` | User is not authenticated | Authenticate and resend the request |
| `auth/forbidden` | User lacks required permissions | Verify permissions or contact an administrator |
| `validation/error` | Request body failed validation | Fix the input fields and retry immediately |
| `not_found` | Requested resource does not exist | Ensure the ID or path is correct |
| `rate_limited` | Too many requests | Wait for the limit window to pass before retrying |
| `server_error` | Internal server error | Retry later; if persistent, contact support |


### 6.3. API Policies

**Authentication:**
- All protected endpoints require a JWT token.
- The token must be included in the `Authorization` header as `Bearer <token>`.

**Rate Limiting:**
- **Authenticated users:** 100 requests per minute.
- **Unauthenticated users:** 20 requests per minute.

## 7. Golden Configurations

[VIMES_NOTE: This section will house the canonical, copy-pasteable configuration files for setting up the project's infrastructure as outlined in the `Epic-0_Setup-Plan.md`. This includes the `Dockerfile`, `docker-compose.yml`, GitHub Actions workflows, `.eslintrc.json`, `.prettierrc.json`, and other key configuration artifacts. It will be populated during the execution of Epic 0.]

## 8. Error Handling Reference

[VIMES_NOTE: This section provides the tactical code examples and references required to implement the strategy defined in `Architecture.md`. It will be populated during the execution of Epic 0.]

### 8.1. Base Error Class

This is the standard base class from which all custom application errors should inherit.

```typescript
// [Placeholder: Example of PUMP_Error base class]
class PUMP_Error extends Error {
  public readonly code: string;
  public readonly cause?: Error;

  constructor(params: { name: string; code: string; message: string; cause?: Error }) {
    super(params.message);
    this.name = params.name;
    this.code = params.code;
    this.cause = params.cause;
  }
}
```

### 8.2. Custom Error Example

This demonstrates how to create a specific, structured error for a business logic failure.

```typescript
// [Placeholder: Example of a specific custom error like PermissionDeniedError]
class PermissionDeniedError extends PUMP_Error {
  constructor({ message, cause }: { message?: string; cause?: Error }) {
    super({
      name: 'PermissionDeniedError',
      code: 'PERMISSION_DENIED',
      message: message ?? 'The user does not have permission to perform this action.',
      cause,
    });
  }
}
```

### 8.3. Standard Adapter Retry Logic

This is a reference implementation for a retry mechanism using exponential backoff for transient network errors in adapters.

```typescript
// [Placeholder: Example of a retry function for adapters]
import { retry, AbortError } from 'p-retry';

async function callWithRetry(externalApiCall: () => Promise<any>) {
  return await retry(
    async () => {
      const response = await externalApiCall();
      // Add logic to check for specific non-retriable server errors
      if (response.status >= 400 && response.status < 500) {
        // Don't retry on 4xx client errors
        throw new AbortError(`Client error: ${response.status}`);
      }
      return response;
    },
    {
      retries: 3, // Number of retries
      factor: 2, // Exponential backoff factor
      minTimeout: 1000, // Initial timeout
      onFailedAttempt: (error) => {
        console.warn(
          `Attempt ${error.attemptNumber} failed. There are ${error.retriesLeft} retries left.`
        );
      },
    }
  );
}
```

### 8.4. Custom Error Code Reference

This table defines the application-specific error codes that the tRPC API will return.

| Code | Meaning | Example Scenario |
| :--- | :--- | :--- |
| `PERMISSION_DENIED` | The authenticated user is not authorized to perform the action or access the resource. | A non-admin user attempts to access an admin-only dashboard. |
| `VALIDATION_FAILED` | The input data failed validation checks. | A user submits a registration form with an invalid email format. |
| `RESOURCE_NOT_FOUND` | The requested resource could not be found. | A user tries to view a profile for an ID that does not exist. |
| `DUPLICATE_RESOURCE` | An attempt was made to create a resource that already exists. | A user tries to register with an email that is already in use. |
| `LAST_ADMIN_IN_ORG` | An attempt was made to remove the last admin from an organization. | The sole administrator of a team tries to leave or demote themselves. |
| **[More to be defined]** | ... | ... |

## 9. Security Implementation Patterns & Checklists

[VIMES_NOTE: This section provides the tactical code examples and references required to implement the security principles defined in `Architecture.md`.]

### 9.1. HTTP Security Headers

This is a reference implementation for adding standard security headers using a middleware approach.

```typescript
// [Placeholder: Example of setting security headers in Next.js, possibly with a library like `helmet`]

// Example for next.config.js
const securityHeaders = [
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload'
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff'
  },
  {
    key: 'X-Frame-Options',
    value: 'DENY'
  }
];

module.exports = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: securityHeaders,
      },
    ];
  },
};
```

### 9.2. New Endpoint Security Checklist

Before a Pull Request containing a new API endpoint can be merged, the developer (human or AI) must confirm the following points have been addressed:

- [ ] **Authentication:** Is the tRPC procedure protected by the authentication middleware? (Or is it explicitly and correctly marked as public?)
- [ ] **Input Validation:** Is all input from the client validated with a strict Zod schema?
- [ ] **Authorization:** Does the service layer logic correctly check if the authenticated user has the required permissions (RBAC) to perform this action?
- [ ] **Least Privilege:** Does the function only access the specific database fields and external services it absolutely needs?
- [ ] **Error Handling:** Are all potential errors (e.g., validation failures, permission denied, resource not found) caught and mapped to the appropriate structured `PUMP_Error` type?
- [ ] **Logging:** Are sensitive details (e.g., passwords, tokens) omitted from all log messages?

## 10. Local Development & Database Management

[VIMES_NOTE: This section provides the essential Supabase CLI commands for managing the local development environment, ensuring consistency with the production setup.]

### 10.1. Initial Setup

First-time setup for a new developer.

```bash
# Start the local Supabase services (PostgreSQL, GoTrue, etc.)
# This will create a local database instance based on your migrations.
supabase start
```

### 10.2. Generating Migrations

When you make a change to your database schema (e.g., using Supabase Studio or a `schema.prisma` file if using Prisma), you must generate a new migration file.

```bash
# Create a new migration file from the changes in your local database.
# Replace 'your_migration_name' with a descriptive name (e.g., 'add_user_roles').
supabase db diff -f your_migration_name
```

### 10.3. Resetting Local Database

To reset your local database to a clean state, based on the existing migrations.

```bash
# This will stop the local services, delete the database volume, and restart it.
supabase stop --no-backup
supabase start
```
